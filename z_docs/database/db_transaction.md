
### 事务ACID性质

传统的关系型数据库中，常常用ACID性质来检验事务功能的可靠性和安全性。

事务总是具有 原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)和耐久性(Durability)。

原子性是基础，隔离性是手段，持久性是目的，真正的老大就是一致性。

![transaction](https://github.com/SwanSpouse/redis_go/blob/master/z_docs/database/transaction.png?raw=true)

#### 原子性

原子性：数据库将事务中的多个操作当做一个整体来执行，服务器要么就执行事务中的所有操作，要么一个操作也不执行。

#### 一致性

一致性：如果数据库在执行事务之前是一致的，那么在事务执行之后，无论事务是否执行成功，数据库也应该是一致的。

拿银行转账来说，一致性要求事务的执行不应改变A、B 两个账户的金额总和。如果没有这种一致性要求，转账过程中就会发生钱无中生有，或者不翼而飞的现象。

#### 隔离性

隔离性：即使数据库中有多个事务并发地执行，各个事务之间也不会相互影响。并在并发状态下执行的事务和串行执行的事务产生的结果完全相同。

#### 耐久性

耐久性：事务的耐久性是指，当一个事务执行完毕时，执行这个事务所得的结果已经被保存到永久性存储介质（硬盘）里面了，即使服务器在事务执行完毕之后停机，
执行事务所得的结果也不会丢失。


### 事务的并发问题

#### 脏读（Dirty Read）
事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据。

![dirty_read](https://github.com/SwanSpouse/redis_go/blob/master/z_docs/database/dirty_read.png?raw=true)

余额应该为 1500 元才对！请看 T5 时间点，事务 A 此时查询余额为 0 元，这个数据就是脏数据，它是事务 B 造成的，明显事务没有进行隔离。


#### 不可重复读（Unrepeatable Read）
事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。

![unrepeatable_read](https://github.com/SwanSpouse/redis_go/blob/master/z_docs/database/unrepeatable_read.png?raw=true)

事务 A 其实除了查询了两次以外，其他什么事情都没有做，结果钱就从 1000 变成 0 了，这就是重复读了。可想而知，这是别人干的，不是我干的。其实这样也是合理的，毕竟事务 B 提交了事务，数据库将结果进行了持久化，所以事务 A 再次读取自然就发生了变化。

#### 幻读（Phantom Read）
事务A重新执行一个查询，返回一系列符合查询条件的行，发现其中存在被事务B提交的行。

#### 补充
不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表

第一条脏读是坚决抵制的，后两条在大多数情况下可不作考虑。

### MySQL事务隔离级别

事务的4种隔离级别  读未提交(RU), 读已提交(RC), 可重复读(RR), 串行

|事务隔离级别 |	脏读  |	不可重复读 |	幻读
| --------  | -----: |    -----:   | :----: |
| 读未提交（read-uncommitted）|  是  |	 是 |  是
| 读已提交（read-committed）  |  否  |  是  | 是
| 可重复读（repeatable-read） |  否  |  否  | 是
| 串行化（serializable）      |	否 |  否  |  否

mysql默认的事务隔离级别为repeatable-read

补充:
1. SQL规范所规定的标准，不同的数据库具体的实现可能会有些差异
2. mysql中默认事务隔离级别是可重复读时并不会锁住读取到的行
3. 事务隔离级别为读提交时，写数据只会锁住相应的行
4. 事务隔离级别为可重复读时，如果有索引（包括主键索引）的时候，以索引列为条件更新数据，会存在间隙锁间隙锁、行锁、下一键锁的问题，从而锁住一些行；如果没有索引，更新数据时会锁住整张表。
5. 事务隔离级别为串行化时，读写数据都会锁住整张表。
6. 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大，鱼和熊掌不可兼得啊。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为Read Committed，它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、幻读这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。

### reference
* https://www.cnblogs.com/huanongying/p/7021555.html
* https://my.oschina.net/huangyong/blog/160012?p=2&temp=1488433678873
