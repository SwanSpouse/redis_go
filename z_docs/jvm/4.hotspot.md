
## HotSpot的算法实现

### 枚举根节点

可达性分析对执行时间的敏感还体现在GC停顿上。因为这项分析工作必须在一个能确保一致性的快照中进行--这里“一致性” 的意思是指整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到满足。这点是导致GC进行时必须停顿所有Java执行线程(Stop The World)的其中一个重要原因。

在HotSpot的实现中，是使用一组OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样，GC在扫描时就可以直接得知这些信息了。

### 安全点 (Safepoint)

在OopMap的协助下，HotSpot可以快速且准确的完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说OopMap内容变化的指令非常多，如果为每一条指令都生成对应的OopMap，那将会需要大量的额外空间，这样GC的空间成本将会变得很高。

实际上，HotSpot也的确没有为每条指令都生成OopMap，只是在“特定的位置”记录了这些信息，这些位置成为安全点(Safepoint)，即程序执行时并非在所有地方都能停顿下来开始GC，只有在达到安全点才能暂停。

另一个需要考虑的问题是如果在GC发生时让所有的线程都跑到最近的安全点再停顿下来。有两种方法
* 抢占式中断(Preemtive Suspension)： 不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部终端，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机采用抢占式终端来暂停线程从而响应GC事件。
* 主动式中断(Voluntary Suspension)：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志位为true时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

### 安全区域 (Safe Region)

Safepoint解决了如何进入GC的问题，但当程序处于Sleep状态或者Blocked状态，这时候线程无法响应JVM中断请求，这种情况就需要安全区域来解决。

安全区域是指在一段代码中，引用关系不会发生变化。在这个区域中的任何地方开始GC都是安全的。

在线程执行到Safe Region中的代码时，首先表示自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举，如果完成了，那线程就继续执行，否则它就必须等待知道收到可以安全离开Safe Region的信号为止。
