## JVM 对象

#### 对象的创建

虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载，解析和初始化过。如果没有，那必须先执行相应的类夹在过程。

在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来。

内存分配的两种方法：
* 指针碰撞(Bump the Pointer) ： 假设Java堆内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲那边挪动一段与对象大小相等的距离。
* 空闲列表(Free List) : 如果Java堆内存并不是规整的。已使用的内存和空闲的内存相互交错，就没有办法使用指针碰撞了。虚拟机就必须维护一个列表，记录上哪些内存块是可以使用的，在分配的时候从列表中找到一个块足够大的空间划分给对象实例，并更新列表上的记录。
* ps: 选择哪种分配方式是由Java堆是否规整决定的，Java堆是否规整又是由所采用的垃圾收集器是否带有压缩整理功能决定的。
	* Serial、ParNew等带Compact过程的收集器，系统采用的分配方式是指针碰撞。
	* CMS这种机遇Mark-Sweep算法的收集器时，通常采用空闲列表。

#### 对象的线程安全问题

解决内存分配的线程安全问题有两种方法：
* 一种是对分配的内存空间的动作进行同步处理 —— 实际上虚拟机采用CAS配上失败重试的方法保证更新操作的原子性。
* 另一种是把内存分配的动作按照线程划分到不同的空间之中进行。即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定。虚拟机是否使用TLAB，可以用过 -XX:+/-UseTLAB 参数来设定。

#### 虚拟机对对象进行必要的设置

对象属于哪个实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象头(Object Header)之中。根据虚拟机的当前的运行状态的不同，如是否使用偏向锁等，对象头会有不同的设置方式。

#### 对象的内存布局

在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instance Data）和对齐补充（Padding）。

对象头，HotSpot虚拟机的对象头包括两部分信息
* 第一部分用于存储对象自身的运行时数据，如哈希码（HashCode），GC分代年龄、锁状态标志、线程持有的错、偏向线程ID、偏向时间戳等，这部分数据在长度在32位和64位的虚拟机中分别为32bit和64bit，官方称之为“Mark Word”。
* 另一部分是类型指针。对象指向它的类元数据的指针，用于确定对象是哪个类的实例。但并不是所有对象都保留类型指针，如数组。对象头中必须还有一块用于记录数组长度的数据。

实例数据，真正存储的有效信息。也是在程序代码中定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的。在分配策略中，相同宽度的字段总是被分配到一起。

对齐字段，对象的大小必须为8字节的整数倍。对象实例数据部分没有对齐时，就需要通过对齐补充来补全。


#### 对象的访问定位

Java需要通过栈上的reference数据来操作堆上的具体对象。访问方式有使用句柄和直接指针两种。
* 使用句柄访问：Java堆中会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。

 ![使用句柄访问](http://img.my.csdn.net/uploads/201209/26/1348659242_7055.jpg)

* 使用直接指针访问：那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。

 ![使用直接指针访问](http://img.my.csdn.net/uploads/201209/26/1348658605_5211.jpg)

* 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾回收）时只改变句柄中的实例数据指针，而reference本身不需要修改。
* 使用直接指针访问最大的好处就是速度更快，它节省了一次指针定位的时间开销。虚拟机Sun HotSpot使用第二种方式进行对象访问。
